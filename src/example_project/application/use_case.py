"""\nUse Case Implementations\n\nThis module defines the use cases for the application. Use cases represent specific\nbusiness operations and orchestrate the flow between domain entities and adapters.\n\nClean Architecture Benefits Demonstrated:\n-----------------------------------------\n1. **Dependency Inversion**: Use cases depend on protocols (abstractions), not concrete\n   implementations. This allows swapping storage backends, API clients, or parsers\n   without changing the use case logic.\n\n2. **Single Responsibility**: Each use case does one thing. DownloadAndStore handles\n   the complete flow of downloading, parsing, and storing data.\n\n3. **Testability**: Use cases can be tested with mock implementations of protocols,\n   enabling fast, isolated unit tests.\n\nUse Case Pattern:\n-----------------\nAll use cases implement the UseCase protocol with an execute() method. This provides\na consistent interface for executing business operations throughout the application.\n\"\""\n\nfrom example_project.adapter.protocols import ApiClass, Parser, Storage\nfrom example_project.composition.context import Context\nfrom typing import Protocol\n\n\nclass UseCase(Protocol):\n    \"\"\"\n    Base protocol for all use cases in the application.\n    \n    The UseCase protocol establishes a consistent interface for executing business\n    operations. This allows use cases to be:\n    - Called uniformly via execute()\n    - Composed and chained together\n    - Wrapped with cross-cutting concerns (logging, monitoring, transactions)\n    \n    The __call__ method provides syntactic sugar, allowing use cases to be invoked\n    like functions: use_case() instead of use_case.execute()\n    \"\"\"\n    def execute(self) -> None: ...\n\n    def __call__(self) -> None:\n        self.execute()\n\n\nclass DownloadAndStore(UseCase):\n    \"\"\"\n    Use case for downloading data from an API, parsing it, and storing the result.\n    \n    This use case demonstrates Clean Architecture's Dependency Inversion Principle:\n    it depends on abstractions (ApiClass, Parser, Storage protocols) rather than\n    concrete implementations. This provides several key benefits:\n    \n    Benefits:\n    ---------\n    1. **Swappable Components**: Change from FrameService to GraphQLService without\n       modifying this class\n    2. **Multiple Storage Options**: Switch between filesystem and Unity Catalog\n       storage by changing the injected dependency\n    3. **Parser Flexibility**: Add JSON→DataFrame or JSON→Domain Entity parsers\n       without touching this use case\n    4. **Testability**: Mock each dependency independently for isolated testing\n    5. **Stability**: This use case should never change due to external system changes\n    \n    Why This Matters:\n    ----------------\n    If we tightly coupled this class to specific implementations (e.g., directly\n    importing GraphQLService), every change to the API or storage system would\n    require modifying this business logic. With dependency injection via protocols,\n    the business logic remains stable and protected from external changes.\n    \n    Parameters:\n    -----------\n    context : Context\n        Application context containing configuration and environment information\n    download_client : ApiClass\n        Protocol implementation for downloading data from external source\n    parser : Parser\n        Protocol implementation for transforming downloaded data\n    storage : Storage\n        Protocol implementation for persisting parsed data\n    \n    Example:\n    --------\n    >>> download_and_store = DownloadAndStore(\n    ...     context=my_context,\n    ...     download_client=GraphQLService(),\n    ...     parser=AsIsParser(),\n    ...     storage=UnityCatalogVolumeStorageService(...)\n    ... )\n    >>> download_and_store.execute()  # Orchestrates the complete flow\n    \"\"\"
    def __init__(
        self,
        context: Context,
        download_client: ApiClass,
        parser: Parser,
        storage: Storage,
    ):
        self.context = context
        self.download_client = download_client
        self.parser = parser
        self.storage = storage

    def execute(self):
        data = self.download_client.download()
        parsed_data = self.parser.parse(data)
        self.storage.save(parsed_data)
