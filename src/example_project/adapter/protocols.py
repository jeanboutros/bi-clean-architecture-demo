"""\nAdapter Protocols - Contracts for External System Integration\n\nThis module defines the protocols (interfaces) that all adapters must implement. Protocols\nestablish contracts between the application core and external systems, enabling dependency\ninversion and loose coupling.\n\nProtocol-Based Design Benefits:\n--------------------------------\n1. **Dependency Inversion**: Application depends on abstractions, not implementations\n2. **Open/Closed Principle**: Add new implementations without modifying existing code\n3. **Liskov Substitution**: All implementations are interchangeable\n4. **Interface Segregation**: Small, focused protocols with single responsibilities\n5. **Testing**: Easy to create test doubles (mocks, stubs, fakes)\n\nWhy Protocols Instead of Abstract Base Classes:\n-----------------------------------------------\nPython protocols use structural subtyping (duck typing) rather than nominal subtyping.\nThis means a class implements a protocol by having the required methods/attributes,\nwithout explicitly inheriting from it. This provides:\n- Less coupling (no inheritance required)\n- Better compatibility with third-party code\n- More Pythonic and flexible design\n\nProtocol Usage Pattern:\n-----------------------\n1. Define protocol in this module (e.g., ApiClass)\n2. Create implementation in appropriate subdirectory (e.g., interface/graphql_service.py)\n3. Use type hints with protocol in application layer\n4. Wire concrete implementation in composition layer\n\"\""\n\nfrom typing import Protocol, Any, runtime_checkable\nfrom pathlib import Path\n\n\nclass ApiClass(Protocol):\n    \"\"\"\n    Protocol for external API clients that download data.\n    \n    This protocol abstracts the concept of \"downloading data from somewhere\". The actual\n    source could be:\n    - REST API (FrameService)\n    - GraphQL API (GraphQLService)\n    - File system\n    - Message queue\n    - Database\n    \n    Benefits:\n    ---------\n    - Application layer doesn't know or care about API implementation details\n    - Easy to add new API sources without changing business logic\n    - Can mock for testing without network calls\n    - Supports multiple API versions simultaneously\n    \n    Example Implementations:\n    ------------------------\n    - FrameService: REST-style API client\n    - GraphQLService: GraphQL-style API client\n    \n    Returns:\n        Any: Raw data structure from the API (typically dict or list)\n    \"\"\"\n    def download(self) -> Any: ...\n\n\nclass Parser(Protocol):\n    \"\"\"\n    Protocol for transforming downloaded data into application-specific format.\n    \n    Parsers sit between the API and storage, transforming raw API responses into\n    the format required by the application or storage layer. This separation allows:\n    \n    Benefits:\n    ---------\n    - API response format changes don't affect storage layer\n    - Can transform data differently for different destinations\n    - Add validation, enrichment, or filtering logic\n    - Convert between formats (JSON → DataFrame, JSON → Domain Entities)\n    \n    Example Implementations:\n    ------------------------\n    - AsIsParser: Pass-through with no transformation\n    - JsonToDataFrameParser: Convert JSON to pandas DataFrame\n    - JsonToDomainEntityParser: Map JSON to domain model instances\n    \n    Parameters:\n        p: Raw data from API (Any type to support various formats)\n    \n    Returns:\n        Any: Parsed/transformed data ready for storage\n    \"\"\"\n    def parse(self, p: Any) -> Any: ...\n\n\n@runtime_checkable\nclass Storage(Protocol):\n    \"\"\"\n    Protocol for persisting data to storage systems.\n    \n    The Storage protocol abstracts data persistence, allowing the application to\n    save data without knowing the underlying storage mechanism. This enables:\n    \n    Benefits:\n    ---------\n    - Switch between storage backends without changing business logic\n    - Support multiple storage destinations simultaneously\n    - Test with in-memory storage instead of real databases\n    - Add new storage types (cloud, database) easily\n    \n    Runtime Checkable:\n    ------------------\n    The @runtime_checkable decorator allows isinstance() checks at runtime.\n    This enables type guards for distinguishing between storage implementations.\n    \n    Example Implementations:\n    ------------------------\n    - StorageService: Local/network filesystem storage\n    - UnityCatalogVolumeStorageService: Databricks Unity Catalog volumes\n    - S3StorageService: AWS S3 buckets (future)\n    - DatabaseStorageService: Relational database (future)\n    \n    Attributes:\n        storage_type: Identifier for the storage backend type\n    \n    Parameters:\n        d: Data to persist (format depends on parser output)\n    \"\"\"\n    storage_type: str\n\n    def save(self, d: Any) -> None: ...\n\n\n@runtime_checkable\nclass UnityCatalogStorage(Protocol):\n    \"\"\"\n    Specialised protocol for Databricks Unity Catalog volume storage.\n    \n    This protocol extends the Storage concept with Unity Catalog-specific configuration.\n    Unity Catalog uses a three-level namespace (catalog.schema.volume) for organising\n    data in Databricks environments.\n    \n    Why a Separate Protocol:\n    ------------------------\n    Unity Catalog requires specific initialisation parameters (catalog_name, schema_name,\n    volume_name) that don't apply to other storage types. Having a separate protocol:\n    - Makes these requirements explicit\n    - Enables type guards for Unity Catalog-specific logic\n    - Maintains flexibility for other storage types\n    \n    Type Guards:\n    ------------\n    Use with type guards (see composition/frames.py) to handle Unity Catalog-specific\n    initialisation whilst maintaining protocol-based abstraction:\n    \n        if is_unity_catalog_storage(storage_class):\n            storage = storage_class(catalog_name=..., schema_name=..., ...)\n        else:\n            storage = storage_class(file_path=...)\n    \n    Parameters:\n        catalog_name: Unity Catalog catalog identifier\n        schema_name: Schema within the catalog\n        volume_name: Volume within the schema\n        file_path: Relative path within the volume\n    \"\"\"\n    storage_type: str\n\n    def __init__(\n        self, catalog_name: str, schema_name: str, volume_name: str, file_path: Path\n    ): ...\n\n    def save(self, d: Any) -> None: ...
